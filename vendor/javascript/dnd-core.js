import{createStore as e}from"redux";import{invariant as t}from"@react-dnd/invariant";import{asap as r}from"@react-dnd/asap";
/**
 * drop-in replacement for _.get
 * @param obj
 * @param path
 * @param defaultValue
 */
function get(e,t,r){return t.split(".").reduce(((e,t)=>e&&e[t]?e[t]:r||null),e)}function without(e,t){return e.filter((e=>e!==t))}
/**
 * drop-in replacement for _.isString
 * @param input
 */
/**
 * drop-in replacement for _.isString
 * @param input
 */
function isObject(e){return"object"===typeof e}
/**
 * replacement for _.xor
 * @param itemsA
 * @param itemsB
 */function xor(e,t){const r=new Map;const insertItem=e=>{r.set(e,r.has(e)?r.get(e)+1:1)};e.forEach(insertItem);t.forEach(insertItem);const n=[];r.forEach(((e,t)=>{1===e&&n.push(t)}));return n}
/**
 * replacement for _.intersection
 * @param itemsA
 * @param itemsB
 */function intersection(e,t){return e.filter((e=>t.indexOf(e)>-1))}const n="dnd-core/INIT_COORDS";const o="dnd-core/BEGIN_DRAG";const i="dnd-core/PUBLISH_DRAG_SOURCE";const s="dnd-core/HOVER";const a="dnd-core/DROP";const c="dnd-core/END_DRAG";function setClientOffset(e,t){return{type:n,payload:{sourceClientOffset:t||null,clientOffset:e||null}}}const u={type:n,payload:{clientOffset:null,sourceClientOffset:null}};function createBeginDrag(e){return function beginDrag(t=[],r={publishSource:true}){const{publishSource:n=true,clientOffset:i,getSourceClientOffset:s}=r;const a=e.getMonitor();const c=e.getRegistry();e.dispatch(setClientOffset(i));verifyInvariants$1(t,a,c);const d=getDraggableSource(t,a);if(null==d){e.dispatch(u);return}let f=null;if(i){if(!s)throw new Error("getSourceClientOffset must be defined");verifyGetSourceClientOffsetIsFunction(s);f=s(d)}e.dispatch(setClientOffset(i,f));const l=c.getSource(d);const g=l.beginDrag(a,d);if(null==g)return;verifyItemIsObject(g);c.pinSource(d);const p=c.getSourceType(d);return{type:o,payload:{itemType:p,item:g,sourceId:d,clientOffset:i||null,sourceClientOffset:f||null,isSourcePublic:!!n}}}}function verifyInvariants$1(e,r,n){t(!r.isDragging(),"Cannot call beginDrag while dragging.");e.forEach((function(e){t(n.getSource(e),"Expected sourceIds to be registered.")}))}function verifyGetSourceClientOffsetIsFunction(e){t("function"===typeof e,"When clientOffset is provided, getSourceClientOffset must be a function.")}function verifyItemIsObject(e){t(isObject(e),"Item must be an object.")}function getDraggableSource(e,t){let r=null;for(let n=e.length-1;n>=0;n--)if(t.canDragSource(e[n])){r=e[n];break}return r}function _defineProperty$3(e,t,r){t in e?Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true}):e[t]=r;return e}function _objectSpread$3(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};var n=Object.keys(r);"function"===typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))));n.forEach((function(t){_defineProperty$3(e,t,r[t])}))}return e}function createDrop(e){return function drop(t={}){const r=e.getMonitor();const n=e.getRegistry();verifyInvariants(r);const o=getDroppableTargets(r);o.forEach(((o,i)=>{const s=determineDropResult(o,i,n,r);const c={type:a,payload:{dropResult:_objectSpread$3({},t,s)}};e.dispatch(c)}))}}function verifyInvariants(e){t(e.isDragging(),"Cannot call drop while not dragging.");t(!e.didDrop(),"Cannot call drop twice during one drag operation.")}function determineDropResult(e,t,r,n){const o=r.getTarget(e);let i=o?o.drop(n,e):void 0;verifyDropResultType(i);"undefined"===typeof i&&(i=0===t?{}:n.getDropResult());return i}function verifyDropResultType(e){t("undefined"===typeof e||isObject(e),"Drop result must either be an object or undefined.")}function getDroppableTargets(e){const t=e.getTargetIds().filter(e.canDropOnTarget,e);t.reverse();return t}function createEndDrag(e){return function endDrag(){const t=e.getMonitor();const r=e.getRegistry();verifyIsDragging(t);const n=t.getSourceId();if(null!=n){const e=r.getSource(n,true);e.endDrag(t,n);r.unpinSource()}return{type:c}}}function verifyIsDragging(e){t(e.isDragging(),"Cannot call endDrag while not dragging.")}function matchesType(e,t){return null===t?null===e:Array.isArray(e)?e.some((e=>e===t)):e===t}function createHover(e){return function hover(t,{clientOffset:r}={}){verifyTargetIdsIsArray(t);const n=t.slice(0);const o=e.getMonitor();const i=e.getRegistry();const a=o.getItemType();removeNonMatchingTargetIds(n,i,a);checkInvariants(n,o,i);hoverAllTargets(n,o,i);return{type:s,payload:{targetIds:n,clientOffset:r||null}}}}function verifyTargetIdsIsArray(e){t(Array.isArray(e),"Expected targetIds to be an array.")}function checkInvariants(e,r,n){t(r.isDragging(),"Cannot call hover while not dragging.");t(!r.didDrop(),"Cannot call hover after drop.");for(let r=0;r<e.length;r++){const o=e[r];t(e.lastIndexOf(o)===r,"Expected targetIds to be unique in the passed array.");const i=n.getTarget(o);t(i,"Expected targetIds to be registered.")}}function removeNonMatchingTargetIds(e,t,r){for(let n=e.length-1;n>=0;n--){const o=e[n];const i=t.getTargetType(o);matchesType(i,r)||e.splice(n,1)}}function hoverAllTargets(e,t,r){e.forEach((function(e){const n=r.getTarget(e);n.hover(t,e)}))}function createPublishDragSource(e){return function publishDragSource(){const t=e.getMonitor();if(t.isDragging())return{type:i}}}function createDragDropActions(e){return{beginDrag:createBeginDrag(e),publishDragSource:createPublishDragSource(e),hover:createHover(e),drop:createDrop(e),endDrag:createEndDrag(e)}}class DragDropManagerImpl{receiveBackend(e){this.backend=e}getMonitor(){return this.monitor}getBackend(){return this.backend}getRegistry(){return this.monitor.registry}getActions(){
/* eslint-disable-next-line @typescript-eslint/no-this-alias */const e=this;const{dispatch:t}=this.store;function bindActionCreator(r){return(...n)=>{const o=r.apply(e,n);"undefined"!==typeof o&&t(o)}}const r=createDragDropActions(this);return Object.keys(r).reduce(((e,t)=>{const n=r[t];e[t]=bindActionCreator(n);return e}),{})}dispatch(e){this.store.dispatch(e)}constructor(e,t){this.isSetUp=false;this.handleRefCountChange=()=>{const e=this.store.getState().refCount>0;if(this.backend)if(e&&!this.isSetUp){this.backend.setup();this.isSetUp=true}else if(!e&&this.isSetUp){this.backend.teardown();this.isSetUp=false}};this.store=e;this.monitor=t;e.subscribe(this.handleRefCountChange)}}
/**
 * Coordinate addition
 * @param a The first coordinate
 * @param b The second coordinate
 */function add(e,t){return{x:e.x+t.x,y:e.y+t.y}}
/**
 * Coordinate subtraction
 * @param a The first coordinate
 * @param b The second coordinate
 */function subtract(e,t){return{x:e.x-t.x,y:e.y-t.y}}
/**
 * Returns the cartesian distance of the drag source component's position, based on its position
 * at the time when the current drag operation has started, and the movement difference.
 *
 * Returns null if no item is being dragged.
 *
 * @param state The offset state to compute from
 */function getSourceClientOffset(e){const{clientOffset:t,initialClientOffset:r,initialSourceClientOffset:n}=e;return t&&r&&n?subtract(add(t,n),r):null}
/**
 * Determines the x,y offset between the client offset and the initial client offset
 *
 * @param state The offset state to compute from
 */function getDifferenceFromInitialOffset(e){const{clientOffset:t,initialClientOffset:r}=e;return t&&r?subtract(t,r):null}const d=[];const f=[];d.__IS_NONE__=true;f.__IS_ALL__=true;
/**
 * Determines if the given handler IDs are dirty or not.
 *
 * @param dirtyIds The set of dirty handler ids
 * @param handlerIds The set of handler ids to check
 */function areDirty(e,t){if(e===d)return false;if(e===f||"undefined"===typeof t)return true;const r=intersection(t,e);return r.length>0}class DragDropMonitorImpl{subscribeToStateChange(e,r={}){const{handlerIds:n}=r;t("function"===typeof e,"listener must be a function.");t("undefined"===typeof n||Array.isArray(n),"handlerIds, when specified, must be an array of strings.");let o=this.store.getState().stateId;const handleChange=()=>{const t=this.store.getState();const r=t.stateId;try{const i=r===o||r===o+1&&!areDirty(t.dirtyHandlerIds,n);i||e()}finally{o=r}};return this.store.subscribe(handleChange)}subscribeToOffsetChange(e){t("function"===typeof e,"listener must be a function.");let r=this.store.getState().dragOffset;const handleChange=()=>{const t=this.store.getState().dragOffset;if(t!==r){r=t;e()}};return this.store.subscribe(handleChange)}canDragSource(e){if(!e)return false;const r=this.registry.getSource(e);t(r,`Expected to find a valid source. sourceId=${e}`);return!this.isDragging()&&r.canDrag(this,e)}canDropOnTarget(e){if(!e)return false;const r=this.registry.getTarget(e);t(r,`Expected to find a valid target. targetId=${e}`);if(!this.isDragging()||this.didDrop())return false;const n=this.registry.getTargetType(e);const o=this.getItemType();return matchesType(n,o)&&r.canDrop(this,e)}isDragging(){return Boolean(this.getItemType())}isDraggingSource(e){if(!e)return false;const r=this.registry.getSource(e,true);t(r,`Expected to find a valid source. sourceId=${e}`);if(!this.isDragging()||!this.isSourcePublic())return false;const n=this.registry.getSourceType(e);const o=this.getItemType();return n===o&&r.isDragging(this,e)}isOverTarget(e,t={shallow:false}){if(!e)return false;const{shallow:r}=t;if(!this.isDragging())return false;const n=this.registry.getTargetType(e);const o=this.getItemType();if(o&&!matchesType(n,o))return false;const i=this.getTargetIds();if(!i.length)return false;const s=i.indexOf(e);return r?s===i.length-1:s>-1}getItemType(){return this.store.getState().dragOperation.itemType}getItem(){return this.store.getState().dragOperation.item}getSourceId(){return this.store.getState().dragOperation.sourceId}getTargetIds(){return this.store.getState().dragOperation.targetIds}getDropResult(){return this.store.getState().dragOperation.dropResult}didDrop(){return this.store.getState().dragOperation.didDrop}isSourcePublic(){return Boolean(this.store.getState().dragOperation.isSourcePublic)}getInitialClientOffset(){return this.store.getState().dragOffset.initialClientOffset}getInitialSourceClientOffset(){return this.store.getState().dragOffset.initialSourceClientOffset}getClientOffset(){return this.store.getState().dragOffset.clientOffset}getSourceClientOffset(){return getSourceClientOffset(this.store.getState().dragOffset)}getDifferenceFromInitialOffset(){return getDifferenceFromInitialOffset(this.store.getState().dragOffset)}constructor(e,t){this.store=e;this.registry=t}}const l="dnd-core/ADD_SOURCE";const g="dnd-core/ADD_TARGET";const p="dnd-core/REMOVE_SOURCE";const h="dnd-core/REMOVE_TARGET";function addSource(e){return{type:l,payload:{sourceId:e}}}function addTarget(e){return{type:g,payload:{targetId:e}}}function removeSource(e){return{type:p,payload:{sourceId:e}}}function removeTarget(e){return{type:h,payload:{targetId:e}}}function validateSourceContract(e){t("function"===typeof e.canDrag,"Expected canDrag to be a function.");t("function"===typeof e.beginDrag,"Expected beginDrag to be a function.");t("function"===typeof e.endDrag,"Expected endDrag to be a function.")}function validateTargetContract(e){t("function"===typeof e.canDrop,"Expected canDrop to be a function.");t("function"===typeof e.hover,"Expected hover to be a function.");t("function"===typeof e.drop,"Expected beginDrag to be a function.")}function validateType(e,r){r&&Array.isArray(e)?e.forEach((e=>validateType(e,false))):t("string"===typeof e||"symbol"===typeof e,r?"Type can only be a string, a symbol, or an array of either.":"Type can only be a string or a symbol.")}var y;(function(e){e.SOURCE="SOURCE";e.TARGET="TARGET"})(y||(y={}));let S=0;function getNextUniqueId(){return S++}function getNextHandlerId(e){const t=getNextUniqueId().toString();switch(e){case y.SOURCE:return`S${t}`;case y.TARGET:return`T${t}`;default:throw new Error(`Unknown Handler Role: ${e}`)}}function parseRoleFromHandlerId(e){switch(e[0]){case"S":return y.SOURCE;case"T":return y.TARGET;default:throw new Error(`Cannot parse handler ID: ${e}`)}}function mapContainsValue(e,t){const r=e.entries();let n=false;do{const{done:e,value:[,o]}=r.next();if(o===t)return true;n=!!e}while(!n);return false}class HandlerRegistryImpl{addSource(e,t){validateType(e);validateSourceContract(t);const r=this.addHandler(y.SOURCE,e,t);this.store.dispatch(addSource(r));return r}addTarget(e,t){validateType(e,true);validateTargetContract(t);const r=this.addHandler(y.TARGET,e,t);this.store.dispatch(addTarget(r));return r}containsHandler(e){return mapContainsValue(this.dragSources,e)||mapContainsValue(this.dropTargets,e)}getSource(e,r=false){t(this.isSourceId(e),"Expected a valid source ID.");const n=r&&e===this.pinnedSourceId;const o=n?this.pinnedSource:this.dragSources.get(e);return o}getTarget(e){t(this.isTargetId(e),"Expected a valid target ID.");return this.dropTargets.get(e)}getSourceType(e){t(this.isSourceId(e),"Expected a valid source ID.");return this.types.get(e)}getTargetType(e){t(this.isTargetId(e),"Expected a valid target ID.");return this.types.get(e)}isSourceId(e){const t=parseRoleFromHandlerId(e);return t===y.SOURCE}isTargetId(e){const t=parseRoleFromHandlerId(e);return t===y.TARGET}removeSource(e){t(this.getSource(e),"Expected an existing source.");this.store.dispatch(removeSource(e));r((()=>{this.dragSources.delete(e);this.types.delete(e)}))}removeTarget(e){t(this.getTarget(e),"Expected an existing target.");this.store.dispatch(removeTarget(e));this.dropTargets.delete(e);this.types.delete(e)}pinSource(e){const r=this.getSource(e);t(r,"Expected an existing source.");this.pinnedSourceId=e;this.pinnedSource=r}unpinSource(){t(this.pinnedSource,"No source is pinned at the time.");this.pinnedSourceId=null;this.pinnedSource=null}addHandler(e,t,r){const n=getNextHandlerId(e);this.types.set(n,t);e===y.SOURCE?this.dragSources.set(n,r):e===y.TARGET&&this.dropTargets.set(n,r);return n}constructor(e){this.types=new Map;this.dragSources=new Map;this.dropTargets=new Map;this.pinnedSourceId=null;this.pinnedSource=null;this.store=e}}const strictEquality=(e,t)=>e===t
/**
 * Determine if two cartesian coordinate offsets are equal
 * @param offsetA
 * @param offsetB
 */;function areCoordsEqual(e,t){return!e&&!t||!(!e||!t)&&(e.x===t.x&&e.y===t.y)}
/**
 * Determines if two arrays of items are equal
 * @param a The first array of items
 * @param b The second array of items
 */function areArraysEqual(e,t,r=strictEquality){if(e.length!==t.length)return false;for(let n=0;n<e.length;++n)if(!r(e[n],t[n]))return false;return true}function reduce$5(e=d,t){switch(t.type){case s:break;case l:case g:case h:case p:return d;case o:case i:case c:case a:default:return f}const{targetIds:r=[],prevTargetIds:n=[]}=t.payload;const u=xor(r,n);const y=u.length>0||!areArraysEqual(r,n);if(!y)return d;const S=n[n.length-1];const b=r[r.length-1];if(S!==b){S&&u.push(S);b&&u.push(b)}return u}function _defineProperty$2(e,t,r){t in e?Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true}):e[t]=r;return e}function _objectSpread$2(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};var n=Object.keys(r);"function"===typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))));n.forEach((function(t){_defineProperty$2(e,t,r[t])}))}return e}const b={initialSourceClientOffset:null,initialClientOffset:null,clientOffset:null};function reduce$4(e=b,t){const{payload:r}=t;switch(t.type){case n:case o:return{initialSourceClientOffset:r.sourceClientOffset,initialClientOffset:r.clientOffset,clientOffset:r.clientOffset};case s:return areCoordsEqual(e.clientOffset,r.clientOffset)?e:_objectSpread$2({},e,{clientOffset:r.clientOffset});case c:case a:return b;default:return e}}function _defineProperty$1(e,t,r){t in e?Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true}):e[t]=r;return e}function _objectSpread$1(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};var n=Object.keys(r);"function"===typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))));n.forEach((function(t){_defineProperty$1(e,t,r[t])}))}return e}const O={itemType:null,item:null,sourceId:null,targetIds:[],dropResult:null,didDrop:false,isSourcePublic:null};function reduce$3(e=O,t){const{payload:r}=t;switch(t.type){case o:return _objectSpread$1({},e,{itemType:r.itemType,item:r.item,sourceId:r.sourceId,isSourcePublic:r.isSourcePublic,dropResult:null,didDrop:false});case i:return _objectSpread$1({},e,{isSourcePublic:true});case s:return _objectSpread$1({},e,{targetIds:r.targetIds});case h:return-1===e.targetIds.indexOf(r.targetId)?e:_objectSpread$1({},e,{targetIds:without(e.targetIds,r.targetId)});case a:return _objectSpread$1({},e,{dropResult:r.dropResult,didDrop:true,targetIds:[]});case c:return _objectSpread$1({},e,{itemType:null,item:null,sourceId:null,dropResult:null,didDrop:false,isSourcePublic:null,targetIds:[]});default:return e}}function reduce$2(e=0,t){switch(t.type){case l:case g:return e+1;case p:case h:return e-1;default:return e}}function reduce$1(e=0){return e+1}function _defineProperty(e,t,r){t in e?Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true}):e[t]=r;return e}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};var n=Object.keys(r);"function"===typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))));n.forEach((function(t){_defineProperty(e,t,r[t])}))}return e}function reduce(e={},t){return{dirtyHandlerIds:reduce$5(e.dirtyHandlerIds,{type:t.type,payload:_objectSpread({},t.payload,{prevTargetIds:get(e,"dragOperation.targetIds",[])})}),dragOffset:reduce$4(e.dragOffset,t),refCount:reduce$2(e.refCount,t),dragOperation:reduce$3(e.dragOperation,t),stateId:reduce$1(e.stateId)}}function createDragDropManager(e,t,r={},n=false){const o=makeStoreInstance(n);const i=new DragDropMonitorImpl(o,new HandlerRegistryImpl(o));const s=new DragDropManagerImpl(o,i);const a=e(s,t,r);s.receiveBackend(a);return s}function makeStoreInstance(t){const r="undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__;return e(reduce,t&&r&&r({name:"dnd-core",instanceId:"dnd-core"}))}export{y as HandlerRole,createDragDropManager};

