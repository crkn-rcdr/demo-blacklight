import{createContext as e,memo as t,useEffect as r,useLayoutEffect as n,useState as o,useCallback as i,useMemo as s,isValidElement as a,cloneElement as c,useContext as u}from"react";import{jsx as g}from"react/jsx-runtime";import{createDragDropManager as d}from"dnd-core";import{invariant as l}from"@react-dnd/invariant";import h from"fast-deep-equal";import{shallowEqual as p}from"@react-dnd/shallowequal";const f=e({dragDropManager:void 0});function _objectWithoutProperties(e,t){if(null==e)return{};var r=_objectWithoutPropertiesLoose(e,t);var n,o;if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++){n=i[o];t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}}return r}function _objectWithoutPropertiesLoose(e,t){if(null==e)return{};var r={};var n=Object.keys(e);var o,i;for(i=0;i<n.length;i++){o=n[i];t.indexOf(o)>=0||(r[o]=e[o])}return r}let D=0;const C=Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");var I=t((function DndProvider(e){var{children:t}=e,n=_objectWithoutProperties(e,["children"]);const[o,i]=getDndContextValue(n);r((()=>{if(i){const e=getGlobalContext();++D;return()=>{0===--D&&(e[C]=null)}}}),[]);return g(f.Provider,{value:o,children:t})}));function getDndContextValue(e){if("manager"in e){const t={dragDropManager:e.manager};return[t,false]}const t=createSingletonDndContext(e.backend,e.context,e.options,e.debugMode);const r=!e.context;return[t,r]}function createSingletonDndContext(e,t=getGlobalContext(),r,n){const o=t;o[C]||(o[C]={dragDropManager:d(e,t,r,n)});return o[C]}function getGlobalContext(){return"undefined"!==typeof global?global:window}const S=t((function DragPreviewImage({connect:e,src:t}){r((()=>{if("undefined"===typeof Image)return;let r=false;const n=new Image;n.src=t;n.onload=()=>{e(n);r=true};return()=>{r&&e(null)}}));return null}));const m="undefined"!==typeof window?n:r;
/**
 *
 * @param monitor The monitor to collect state from
 * @param collect The collecting function
 * @param onUpdate A method to invoke when updates occur
 */function useCollector(e,t,r){const[n,s]=o((()=>t(e)));const a=i((()=>{const o=t(e);if(!h(n,o)){s(o);r&&r()}}),[n,e,r]);m(a);return[n,a]}function useMonitorOutput(e,t,r){const[n,o]=useCollector(e,t,r);m((function subscribeToMonitorStateChange(){const t=e.getHandlerId();if(null!=t)return e.subscribeToStateChange(o,{handlerIds:[t]})}),[e,o]);return n}function useCollectedProps(e,t,r){return useMonitorOutput(t,e||(()=>({})),(()=>r.reconnect()))}function useOptionalFactory(e,t){const r=[...t||[]];null==t&&"function"!==typeof e&&r.push(e);return s((()=>"function"===typeof e?e():e),r)}function useConnectDragSource(e){return s((()=>e.hooks.dragSource()),[e])}function useConnectDragPreview(e){return s((()=>e.hooks.dragPreview()),[e])}let T=false;let O=false;class DragSourceMonitorImpl{receiveHandlerId(e){this.sourceId=e}getHandlerId(){return this.sourceId}canDrag(){l(!T,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{T=true;return this.internalMonitor.canDragSource(this.sourceId)}finally{T=false}}isDragging(){if(!this.sourceId)return false;l(!O,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{O=true;return this.internalMonitor.isDraggingSource(this.sourceId)}finally{O=false}}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}isDraggingSource(e){return this.internalMonitor.isDraggingSource(e)}isOverTarget(e,t){return this.internalMonitor.isOverTarget(e,t)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(e){return this.internalMonitor.subscribeToOffsetChange(e)}canDragSource(e){return this.internalMonitor.canDragSource(e)}canDropOnTarget(e){return this.internalMonitor.canDropOnTarget(e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.sourceId=null;this.internalMonitor=e.getMonitor()}}let v=false;class DropTargetMonitorImpl{receiveHandlerId(e){this.targetId=e}getHandlerId(){return this.targetId}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}canDrop(){if(!this.targetId)return false;l(!v,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{v=true;return this.internalMonitor.canDropOnTarget(this.targetId)}finally{v=false}}isOver(e){return!!this.targetId&&this.internalMonitor.isOverTarget(this.targetId,e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.targetId=null;this.internalMonitor=e.getMonitor()}}function registerTarget(e,t,r){const n=r.getRegistry();const o=n.addTarget(e,t);return[o,()=>n.removeTarget(o)]}function registerSource(e,t,r){const n=r.getRegistry();const o=n.addSource(e,t);return[o,()=>n.removeSource(o)]}function isRef(e){return null!==e&&"object"===typeof e&&Object.prototype.hasOwnProperty.call(e,"current")}function throwIfCompositeComponentElement(e){if("string"===typeof e.type)return;const t=e.type.displayName||e.type.name||"the component";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`)}function wrapHookToRecognizeElement(e){return(t=null,r=null)=>{if(!a(t)){const n=t;e(n,r);return n}const n=t;throwIfCompositeComponentElement(n);const o=r?t=>e(t,r):e;return cloneWithRef(n,o)}}function wrapConnectorHooks(e){const t={};Object.keys(e).forEach((r=>{const n=e[r];if(r.endsWith("Ref"))t[r]=e[r];else{const e=wrapHookToRecognizeElement(n);t[r]=()=>e}}));return t}function setRef(e,t){"function"===typeof e?e(t):e.current=t}function cloneWithRef(e,t){const r=e.ref;l("string"!==typeof r,"Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");return c(e,r?{ref:e=>{setRef(r,e);setRef(t,e)}}:{ref:t})}class SourceConnector{receiveHandlerId(e){if(this.handlerId!==e){this.handlerId=e;this.reconnect()}}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(e){this.dragSourceOptionsInternal=e}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(e){this.dragPreviewOptionsInternal=e}reconnect(){const e=this.reconnectDragSource();this.reconnectDragPreview(e)}reconnectDragSource(){const e=this.dragSource;const t=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();t&&this.disconnectDragSource();if(!this.handlerId)return t;if(!e){this.lastConnectedDragSource=e;return t}if(t){this.lastConnectedHandlerId=this.handlerId;this.lastConnectedDragSource=e;this.lastConnectedDragSourceOptions=this.dragSourceOptions;this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,e,this.dragSourceOptions)}return t}reconnectDragPreview(e=false){const t=this.dragPreview;const r=e||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();r&&this.disconnectDragPreview();if(this.handlerId)if(t){if(r){this.lastConnectedHandlerId=this.handlerId;this.lastConnectedDragPreview=t;this.lastConnectedDragPreviewOptions=this.dragPreviewOptions;this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,t,this.dragPreviewOptions)}}else this.lastConnectedDragPreview=t}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!p(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!p(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){if(this.dragSourceUnsubscribe){this.dragSourceUnsubscribe();this.dragSourceUnsubscribe=void 0}}disconnectDragPreview(){if(this.dragPreviewUnsubscribe){this.dragPreviewUnsubscribe();this.dragPreviewUnsubscribe=void 0;this.dragPreviewNode=null;this.dragPreviewRef=null}}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null;this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null;this.dragPreviewRef=null}constructor(e){this.hooks=wrapConnectorHooks({dragSource:(e,t)=>{this.clearDragSource();this.dragSourceOptions=t||null;isRef(e)?this.dragSourceRef=e:this.dragSourceNode=e;this.reconnectDragSource()},dragPreview:(e,t)=>{this.clearDragPreview();this.dragPreviewOptions=t||null;isRef(e)?this.dragPreviewRef=e:this.dragPreviewNode=e;this.reconnectDragPreview()}});this.handlerId=null;this.dragSourceRef=null;this.dragSourceOptionsInternal=null;this.dragPreviewRef=null;this.dragPreviewOptionsInternal=null;this.lastConnectedHandlerId=null;this.lastConnectedDragSource=null;this.lastConnectedDragSourceOptions=null;this.lastConnectedDragPreview=null;this.lastConnectedDragPreviewOptions=null;this.backend=e}}class TargetConnector{get connectTarget(){return this.dropTarget}reconnect(){const e=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();e&&this.disconnectDropTarget();const t=this.dropTarget;if(this.handlerId)if(t){if(e){this.lastConnectedHandlerId=this.handlerId;this.lastConnectedDropTarget=t;this.lastConnectedDropTargetOptions=this.dropTargetOptions;this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,t,this.dropTargetOptions)}}else this.lastConnectedDropTarget=t}receiveHandlerId(e){if(e!==this.handlerId){this.handlerId=e;this.reconnect()}}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(e){this.dropTargetOptionsInternal=e}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!p(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){if(this.unsubscribeDropTarget){this.unsubscribeDropTarget();this.unsubscribeDropTarget=void 0}}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null;this.dropTargetNode=null}constructor(e){this.hooks=wrapConnectorHooks({dropTarget:(e,t)=>{this.clearDropTarget();this.dropTargetOptions=t;isRef(e)?this.dropTargetRef=e:this.dropTargetNode=e;this.reconnect()}});this.handlerId=null;this.dropTargetRef=null;this.dropTargetOptionsInternal=null;this.lastConnectedHandlerId=null;this.lastConnectedDropTarget=null;this.lastConnectedDropTargetOptions=null;this.backend=e}}function useDragDropManager(){const{dragDropManager:e}=u(f);l(null!=e,"Expected drag drop context");return e}function useDragSourceConnector(e,t){const r=useDragDropManager();const n=s((()=>new SourceConnector(r.getBackend())),[r]);m((()=>{n.dragSourceOptions=e||null;n.reconnect();return()=>n.disconnectDragSource()}),[n,e]);m((()=>{n.dragPreviewOptions=t||null;n.reconnect();return()=>n.disconnectDragPreview()}),[n,t]);return n}function useDragSourceMonitor(){const e=useDragDropManager();return s((()=>new DragSourceMonitorImpl(e)),[e])}class DragSourceImpl{beginDrag(){const e=this.spec;const t=this.monitor;let r=null;r="object"===typeof e.item?e.item:"function"===typeof e.item?e.item(t):{};return null!==r&&void 0!==r?r:null}canDrag(){const e=this.spec;const t=this.monitor;return"boolean"===typeof e.canDrag?e.canDrag:"function"!==typeof e.canDrag||e.canDrag(t)}isDragging(e,t){const r=this.spec;const n=this.monitor;const{isDragging:o}=r;return o?o(n):t===e.getSourceId()}endDrag(){const e=this.spec;const t=this.monitor;const r=this.connector;const{end:n}=e;n&&n(t.getItem(),t);r.reconnect()}constructor(e,t,r){this.spec=e;this.monitor=t;this.connector=r}}function useDragSource(e,t,n){const o=s((()=>new DragSourceImpl(e,t,n)),[t,n]);r((()=>{o.spec=e}),[e]);return o}function useDragType(e){return s((()=>{const t=e.type;l(null!=t,"spec.type must be defined");return t}),[e])}function useRegisteredDragSource(e,t,r){const n=useDragDropManager();const o=useDragSource(e,t,r);const i=useDragType(e);m((function registerDragSource(){if(null!=i){const[e,s]=registerSource(i,o,n);t.receiveHandlerId(e);r.receiveHandlerId(e);return s}}),[n,t,r,o,i])}
/**
 * useDragSource hook
 * @param sourceSpec The drag source specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */function useDrag(e,t){const r=useOptionalFactory(e,t);l(!r.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");const n=useDragSourceMonitor();const o=useDragSourceConnector(r.options,r.previewOptions);useRegisteredDragSource(r,n,o);return[useCollectedProps(r.collect,n,o),useConnectDragSource(o),useConnectDragPreview(o)]}
/**
 * useDragLayer Hook
 * @param collector The property collector
 */function useDragLayer(e){const t=useDragDropManager();const n=t.getMonitor();const[o,i]=useCollector(n,e);r((()=>n.subscribeToOffsetChange(i)));r((()=>n.subscribeToStateChange(i)));return o}function useConnectDropTarget(e){return s((()=>e.hooks.dropTarget()),[e])}function useDropTargetConnector(e){const t=useDragDropManager();const r=s((()=>new TargetConnector(t.getBackend())),[t]);m((()=>{r.dropTargetOptions=e||null;r.reconnect();return()=>r.disconnectDropTarget()}),[e]);return r}function useDropTargetMonitor(){const e=useDragDropManager();return s((()=>new DropTargetMonitorImpl(e)),[e])}
/**
 * Internal utility hook to get an array-version of spec.accept.
 * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.
 * @param spec
 */function useAccept(e){const{accept:t}=e;return s((()=>{l(null!=e.accept,"accept must be defined");return Array.isArray(t)?t:[t]}),[t])}class DropTargetImpl{canDrop(){const e=this.spec;const t=this.monitor;return!e.canDrop||e.canDrop(t.getItem(),t)}hover(){const e=this.spec;const t=this.monitor;e.hover&&e.hover(t.getItem(),t)}drop(){const e=this.spec;const t=this.monitor;if(e.drop)return e.drop(t.getItem(),t)}constructor(e,t){this.spec=e;this.monitor=t}}function useDropTarget(e,t){const n=s((()=>new DropTargetImpl(e,t)),[t]);r((()=>{n.spec=e}),[e]);return n}function useRegisteredDropTarget(e,t,r){const n=useDragDropManager();const o=useDropTarget(e,t);const i=useAccept(e);m((function registerDropTarget(){const[e,s]=registerTarget(i,o,n);t.receiveHandlerId(e);r.receiveHandlerId(e);return s}),[n,t,o,r,i.map((e=>e.toString())).join("|")])}
/**
 * useDropTarget Hook
 * @param spec The drop target specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */function useDrop(e,t){const r=useOptionalFactory(e,t);const n=useDropTargetMonitor();const o=useDropTargetConnector(r.options);useRegisteredDropTarget(r,n,o);return[useCollectedProps(r.collect,n,o),useConnectDropTarget(o)]}export{f as DndContext,I as DndProvider,S as DragPreviewImage,useDrag,useDragDropManager,useDragLayer,useDrop};

