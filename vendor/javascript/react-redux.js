import*as e from"react";import{useSyncExternalStoreWithSelector as t}from"use-sync-external-store/with-selector.js";var r="default"in e?e.default:e;var n=Symbol.for("react-redux-context");var o=typeof globalThis!=="undefined"?globalThis:{};function getContext(){if(!r.createContext)return{};const e=o[n]??(o[n]=new Map);let t=e.get(r.createContext);if(!t){t=r.createContext(null);process.env.NODE_ENV!=="production"&&(t.displayName="ReactRedux");e.set(r.createContext,t)}return t}var s=getContext();var notInitialized=()=>{throw new Error("uSES not initialized!")};function createReduxContextHook(e=s){return function useReduxContext2(){const t=r.useContext(e);if(process.env.NODE_ENV!=="production"&&!t)throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");return t}}var c=createReduxContextHook();var a=notInitialized;var initializeUseSelector=e=>{a=e};var refEquality=(e,t)=>e===t;function createSelectorHook(e=s){const t=e===s?c:createReduxContextHook(e);const useSelector2=(e,n={})=>{const{equalityFn:o=refEquality,devModeChecks:s={}}=typeof n==="function"?{equalityFn:n}:n;if(process.env.NODE_ENV!=="production"){if(!e)throw new Error("You must pass a selector to useSelector");if(typeof e!=="function")throw new Error("You must pass a function as a selector to useSelector");if(typeof o!=="function")throw new Error("You must pass a function as an equality function to useSelector")}const{store:c,subscription:u,getServerState:i,stabilityCheck:p,identityFunctionCheck:l}=t();const f=r.useRef(true);const d=r.useCallback({[e.name](t){const r=e(t);if(process.env.NODE_ENV!=="production"){const{identityFunctionCheck:n,stabilityCheck:c}={stabilityCheck:p,identityFunctionCheck:l,...s};if(c==="always"||c==="once"&&f.current){const n=e(t);if(!o(r,n)){let o;try{throw new Error}catch(e){({stack:o}=e)}console.warn("Selector "+(e.name||"unknown")+" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",{state:t,selected:r,selected2:n,stack:o})}}if((n==="always"||n==="once"&&f.current)&&r===t){let t;try{throw new Error}catch(e){({stack:t}=e)}console.warn("Selector "+(e.name||"unknown")+" returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",{stack:t})}f.current&&(f.current=false)}return r}}[e.name],[e,p,s.stabilityCheck]);const y=a(u.addNestedSub,c.getState,i||c.getState,d,o);r.useDebugValue(y);return y};Object.assign(useSelector2,{withTypes:()=>useSelector2});return useSelector2}var u=createSelectorHook();var i=Symbol.for("react.element");var p=Symbol.for("react.portal");var l=Symbol.for("react.fragment");var f=Symbol.for("react.strict_mode");var d=Symbol.for("react.profiler");var y=Symbol.for("react.provider");var h=Symbol.for("react.context");var m=Symbol.for("react.server_context");var b=Symbol.for("react.forward_ref");var S=Symbol.for("react.suspense");var v=Symbol.for("react.suspense_list");var w=Symbol.for("react.memo");var P=Symbol.for("react.lazy");var g=Symbol.for("react.offscreen");var O=Symbol.for("react.client.reference");var E=b;var C=w;function isValidElementType(e){return typeof e==="string"||typeof e==="function"||(e===l||e===d||e===f||e===S||e===v||e===g||typeof e==="object"&&e!==null&&(e.$$typeof===P||e.$$typeof===w||e.$$typeof===y||e.$$typeof===h||e.$$typeof===b||e.$$typeof===O||e.getModuleId!==void 0))}function typeOf(e){if(typeof e==="object"&&e!==null){const t=e.$$typeof;switch(t){case i:{const r=e.type;switch(r){case l:case d:case f:case S:case v:return r;default:{const e=r&&r.$$typeof;switch(e){case m:case h:case b:case P:case w:case y:return e;default:return t}}}}case p:return t}}}function isContextConsumer(e){return typeOf(e)===h}function isMemo(e){return typeOf(e)===w}function warning(e){typeof console!=="undefined"&&typeof console.error==="function"&&console.error(e);try{throw new Error(e)}catch(e){}}function verify(e,t){if(!e)throw new Error(`Unexpected value for ${t} in connect.`);t!=="mapStateToProps"&&t!=="mapDispatchToProps"||Object.prototype.hasOwnProperty.call(e,"dependsOnOwnProps")||warning(`The selector for ${t} of connect did not specify a value for dependsOnOwnProps.`)}function verifySubselectors(e,t,r){verify(e,"mapStateToProps");verify(t,"mapDispatchToProps");verify(r,"mergeProps")}function pureFinalPropsSelectorFactory(e,t,r,n,{areStatesEqual:o,areOwnPropsEqual:s,areStatePropsEqual:c}){let a=false;let u;let i;let p;let l;let f;function handleFirstCall(o,s){u=o;i=s;p=e(u,i);l=t(n,i);f=r(p,l,i);a=true;return f}function handleNewPropsAndNewState(){p=e(u,i);t.dependsOnOwnProps&&(l=t(n,i));f=r(p,l,i);return f}function handleNewProps(){e.dependsOnOwnProps&&(p=e(u,i));t.dependsOnOwnProps&&(l=t(n,i));f=r(p,l,i);return f}function handleNewState(){const t=e(u,i);const n=!c(t,p);p=t;n&&(f=r(p,l,i));return f}function handleSubsequentCalls(e,t){const r=!s(t,i);const n=!o(e,u,t,i);u=e;i=t;return r&&n?handleNewPropsAndNewState():r?handleNewProps():n?handleNewState():f}return function pureFinalPropsSelector(e,t){return a?handleSubsequentCalls(e,t):handleFirstCall(e,t)}}function finalPropsSelectorFactory(e,{initMapStateToProps:t,initMapDispatchToProps:r,initMergeProps:n,...o}){const s=t(e,o);const c=r(e,o);const a=n(e,o);process.env.NODE_ENV!=="production"&&verifySubselectors(s,c,a);return pureFinalPropsSelectorFactory(s,c,a,e,o)}function bindActionCreators(e,t){const r={};for(const n in e){const o=e[n];typeof o==="function"&&(r[n]=(...e)=>t(o(...e)))}return r}function isPlainObject(e){if(typeof e!=="object"||e===null)return false;const t=Object.getPrototypeOf(e);if(t===null)return true;let r=t;while(Object.getPrototypeOf(r)!==null)r=Object.getPrototypeOf(r);return t===r}function verifyPlainObject(e,t,r){isPlainObject(e)||warning(`${r}() in ${t} must return a plain object. Instead received ${e}.`)}function wrapMapToPropsConstant(e){return function initConstantSelector(t){const r=e(t);function constantSelector(){return r}constantSelector.dependsOnOwnProps=false;return constantSelector}}function getDependsOnOwnProps(e){return e.dependsOnOwnProps?Boolean(e.dependsOnOwnProps):e.length!==1}function wrapMapToPropsFunc(e,t){return function initProxySelector(r,{displayName:n}){const o=function mapToPropsProxy(e,t){return o.dependsOnOwnProps?o.mapToProps(e,t):o.mapToProps(e,void 0)};o.dependsOnOwnProps=true;o.mapToProps=function detectFactoryAndVerify(r,s){o.mapToProps=e;o.dependsOnOwnProps=getDependsOnOwnProps(e);let c=o(r,s);if(typeof c==="function"){o.mapToProps=c;o.dependsOnOwnProps=getDependsOnOwnProps(c);c=o(r,s)}process.env.NODE_ENV!=="production"&&verifyPlainObject(c,n,t);return c};return o}}function createInvalidArgFactory(e,t){return(r,n)=>{throw new Error(`Invalid value of type ${typeof e} for ${t} argument when connecting component ${n.wrappedComponentName}.`)}}function mapDispatchToPropsFactory(e){return e&&typeof e==="object"?wrapMapToPropsConstant((t=>bindActionCreators(e,t))):e?typeof e==="function"?wrapMapToPropsFunc(e,"mapDispatchToProps"):createInvalidArgFactory(e,"mapDispatchToProps"):wrapMapToPropsConstant((e=>({dispatch:e})))}function mapStateToPropsFactory(e){return e?typeof e==="function"?wrapMapToPropsFunc(e,"mapStateToProps"):createInvalidArgFactory(e,"mapStateToProps"):wrapMapToPropsConstant((()=>({})))}function defaultMergeProps(e,t,r){return{...r,...e,...t}}function wrapMergePropsFunc(e){return function initMergePropsProxy(t,{displayName:r,areMergedPropsEqual:n}){let o=false;let s;return function mergePropsProxy(t,c,a){const u=e(t,c,a);if(o)n(u,s)||(s=u);else{o=true;s=u;process.env.NODE_ENV!=="production"&&verifyPlainObject(s,r,"mergeProps")}return s}}}function mergePropsFactory(e){return e?typeof e==="function"?wrapMergePropsFunc(e):createInvalidArgFactory(e,"mergeProps"):()=>defaultMergeProps}function defaultNoopBatch(e){e()}function createListenerCollection(){let e=null;let t=null;return{clear(){e=null;t=null},notify(){defaultNoopBatch((()=>{let t=e;while(t){t.callback();t=t.next}}))},get(){const t=[];let r=e;while(r){t.push(r);r=r.next}return t},subscribe(r){let n=true;const o=t={callback:r,next:null,prev:t};o.prev?o.prev.next=o:e=o;return function unsubscribe(){if(n&&e!==null){n=false;o.next?o.next.prev=o.prev:t=o.prev;o.prev?o.prev.next=o.next:e=o.next}}}}}var N={notify(){},get:()=>[]};function createSubscription(e,t){let r;let n=N;let o=0;let s=false;function addNestedSub(e){trySubscribe();const t=n.subscribe(e);let r=false;return()=>{if(!r){r=true;t();tryUnsubscribe()}}}function notifyNestedSubs(){n.notify()}function handleChangeWrapper(){c.onStateChange&&c.onStateChange()}function isSubscribed(){return s}function trySubscribe(){o++;if(!r){r=t?t.addNestedSub(handleChangeWrapper):e.subscribe(handleChangeWrapper);n=createListenerCollection()}}function tryUnsubscribe(){o--;if(r&&o===0){r();r=void 0;n.clear();n=N}}function trySubscribeSelf(){if(!s){s=true;trySubscribe()}}function tryUnsubscribeSelf(){if(s){s=false;tryUnsubscribe()}}const c={addNestedSub:addNestedSub,notifyNestedSubs:notifyNestedSubs,handleChangeWrapper:handleChangeWrapper,isSubscribed:isSubscribed,trySubscribe:trySubscribeSelf,tryUnsubscribe:tryUnsubscribeSelf,getListeners:()=>n};return c}var x=!!(typeof window!=="undefined"&&typeof window.document!=="undefined"&&typeof window.document.createElement!=="undefined");var T=x?r.useLayoutEffect:r.useEffect;function is(e,t){return e===t?e!==0||t!==0||1/e===1/t:e!==e&&t!==t}function shallowEqual(e,t){if(is(e,t))return true;if(typeof e!=="object"||e===null||typeof t!=="object"||t===null)return false;const r=Object.keys(e);const n=Object.keys(t);if(r.length!==n.length)return false;for(let n=0;n<r.length;n++)if(!Object.prototype.hasOwnProperty.call(t,r[n])||!is(e[r[n]],t[r[n]]))return false;return true}var k={childContextTypes:true,contextType:true,contextTypes:true,defaultProps:true,displayName:true,getDefaultProps:true,getDerivedStateFromError:true,getDerivedStateFromProps:true,mixins:true,propTypes:true,type:true};var F={name:true,length:true,prototype:true,caller:true,callee:true,arguments:true,arity:true};var M={$$typeof:true,render:true,defaultProps:true,displayName:true,propTypes:true};var $={$$typeof:true,compare:true,defaultProps:true,displayName:true,propTypes:true,type:true};var j={[E]:M,[C]:$};function getStatics(e){return isMemo(e)?$:j[e.$$typeof]||k}var D=Object.defineProperty;var R=Object.getOwnPropertyNames;var q=Object.getOwnPropertySymbols;var H=Object.getOwnPropertyDescriptor;var V=Object.getPrototypeOf;var _=Object.prototype;function hoistNonReactStatics(e,t){if(typeof t!=="string"){if(_){const r=V(t);r&&r!==_&&hoistNonReactStatics(e,r)}let r=R(t);q&&(r=r.concat(q(t)));const n=getStatics(e);const o=getStatics(t);for(let s=0;s<r.length;++s){const c=r[s];if(!F[c]&&!(o&&o[c])&&!(n&&n[c])){const r=H(t,c);try{D(e,c,r)}catch(e){}}}}return e}var W=notInitialized;var initializeConnect=e=>{W=e};var A=[null,null];var stringifyComponent=e=>{try{return JSON.stringify(e)}catch(t){return String(e)}};function useIsomorphicLayoutEffectWithArgs(e,t,r){T((()=>e(...t)),r)}function captureWrapperProps(e,t,r,n,o,s){e.current=n;r.current=false;if(o.current){o.current=null;s()}}function subscribeUpdates(e,t,r,n,o,s,c,a,u,i,p){if(!e)return()=>{};let l=false;let f=null;const checkForUpdates=()=>{if(l||!a.current)return;const e=t.getState();let r,d;try{r=n(e,o.current)}catch(e){d=e;f=e}d||(f=null);if(r===s.current)c.current||i();else{s.current=r;u.current=r;c.current=true;p()}};r.onStateChange=checkForUpdates;r.trySubscribe();checkForUpdates();const unsubscribeWrapper=()=>{l=true;r.tryUnsubscribe();r.onStateChange=null;if(f)throw f};return unsubscribeWrapper}function strictEqual(e,t){return e===t}var U=false;function connect(e,t,n,{pure:o,areStatesEqual:c=strictEqual,areOwnPropsEqual:a=shallowEqual,areStatePropsEqual:u=shallowEqual,areMergedPropsEqual:i=shallowEqual,forwardRef:p=false,context:l=s}={}){if(process.env.NODE_ENV!=="production"&&o!==void 0&&!U){U=true;warning('The `pure` option has been removed. `connect` is now always a "pure/memoized" component')}const f=l;const d=mapStateToPropsFactory(e);const y=mapDispatchToPropsFactory(t);const h=mergePropsFactory(n);const m=Boolean(e);const wrapWithConnect=e=>{if(process.env.NODE_ENV!=="production"){const t=isValidElementType(e);if(!t)throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(e)}`)}const t=e.displayName||e.name||"Component";const n=`Connect(${t})`;const o={shouldHandleStateChanges:m,displayName:n,wrappedComponentName:t,WrappedComponent:e,initMapStateToProps:d,initMapDispatchToProps:y,initMergeProps:h,areStatesEqual:c,areStatePropsEqual:u,areOwnPropsEqual:a,areMergedPropsEqual:i};function ConnectFunction(t){const[s,c,a]=r.useMemo((()=>{const{reactReduxForwardedRef:e,...r}=t;return[t.context,e,r]}),[t]);const u=r.useMemo((()=>{let e=f;if(s?.Consumer&&process.env.NODE_ENV!=="production"){const t=isContextConsumer(r.createElement(s.Consumer,null));if(!t)throw new Error("You must pass a valid React context consumer as `props.context`");e=s}return e}),[s,f]);const i=r.useContext(u);const p=Boolean(t.store)&&Boolean(t.store.getState)&&Boolean(t.store.dispatch);const l=Boolean(i)&&Boolean(i.store);if(process.env.NODE_ENV!=="production"&&!p&&!l)throw new Error(`Could not find "store" in the context of "${n}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${n} in connect options.`);const d=p?t.store:i.store;const y=l?i.getServerState:d.getState;const h=r.useMemo((()=>finalPropsSelectorFactory(d.dispatch,o)),[d]);const[b,S]=r.useMemo((()=>{if(!m)return A;const e=createSubscription(d,p?void 0:i.subscription);const t=e.notifyNestedSubs.bind(e);return[e,t]}),[d,p,i]);const v=r.useMemo((()=>p?i:{...i,subscription:b}),[p,i,b]);const w=r.useRef();const P=r.useRef(a);const g=r.useRef();const O=r.useRef(false);r.useRef(false);const E=r.useRef(false);const C=r.useRef();T((()=>{E.current=true;return()=>{E.current=false}}),[]);const N=r.useMemo((()=>{const selector=()=>g.current&&a===P.current?g.current:h(d.getState(),a);return selector}),[d,a]);const x=r.useMemo((()=>{const subscribe=e=>b?subscribeUpdates(m,d,b,h,P,w,O,E,g,S,e):()=>{};return subscribe}),[b]);useIsomorphicLayoutEffectWithArgs(captureWrapperProps,[P,w,O,a,g,S]);let k;try{k=W(x,N,y?()=>h(y(),a):N)}catch(e){C.current&&(e.message+=`\nThe error may be correlated with this previous error:\n${C.current.stack}\n\n`);throw e}T((()=>{C.current=void 0;g.current=void 0;w.current=k}));const F=r.useMemo((()=>r.createElement(e,{...k,ref:c})),[c,e,k]);const M=r.useMemo((()=>m?r.createElement(u.Provider,{value:v},F):F),[u,F,v]);return M}const s=r.memo(ConnectFunction);const l=s;l.WrappedComponent=e;l.displayName=ConnectFunction.displayName=n;if(p){const t=r.forwardRef((function forwardConnectRef(e,t){return r.createElement(l,{...e,reactReduxForwardedRef:t})}));const o=t;o.displayName=n;o.WrappedComponent=e;return hoistNonReactStatics(o,e)}return hoistNonReactStatics(l,e)};return wrapWithConnect}var B=connect;function Provider({store:e,context:t,children:n,serverState:o,stabilityCheck:c="once",identityFunctionCheck:a="once"}){const u=r.useMemo((()=>{const t=createSubscription(e);return{store:e,subscription:t,getServerState:o?()=>o:void 0,stabilityCheck:c,identityFunctionCheck:a}}),[e,o,c,a]);const i=r.useMemo((()=>e.getState()),[e]);T((()=>{const{subscription:t}=u;t.onStateChange=t.notifyNestedSubs;t.trySubscribe();i!==e.getState()&&t.notifyNestedSubs();return()=>{t.tryUnsubscribe();t.onStateChange=void 0}}),[u,i]);const p=t||s;return r.createElement(p.Provider,{value:u},n)}var I=Provider;function createStoreHook(e=s){const t=e===s?c:createReduxContextHook(e);const useStore2=()=>{const{store:e}=t();return e};Object.assign(useStore2,{withTypes:()=>useStore2});return useStore2}var z=createStoreHook();function createDispatchHook(e=s){const t=e===s?z:createStoreHook(e);const useDispatch2=()=>{const e=t();return e.dispatch};Object.assign(useDispatch2,{withTypes:()=>useDispatch2});return useDispatch2}var L=createDispatchHook();var Y=defaultNoopBatch;initializeUseSelector(t);initializeConnect(e.useSyncExternalStore);export{I as Provider,s as ReactReduxContext,Y as batch,B as connect,createDispatchHook,createSelectorHook,createStoreHook,shallowEqual,L as useDispatch,u as useSelector,z as useStore};

