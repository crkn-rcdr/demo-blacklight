import{invariant as e}from"@react-dnd/invariant";var t;(function(e){e.mouse="mouse";e.touch="touch";e.keyboard="keyboard"})(t||(t={}));class OptionsReader{get delay(){var e;return null!==(e=this.args.delay)&&void 0!==e?e:0}get scrollAngleRanges(){return this.args.scrollAngleRanges}get getDropTargetElementsAtPoint(){return this.args.getDropTargetElementsAtPoint}get ignoreContextMenu(){var e;return null!==(e=this.args.ignoreContextMenu)&&void 0!==e&&e}get enableHoverOutsideTarget(){var e;return null!==(e=this.args.enableHoverOutsideTarget)&&void 0!==e&&e}get enableKeyboardEvents(){var e;return null!==(e=this.args.enableKeyboardEvents)&&void 0!==e&&e}get enableMouseEvents(){var e;return null!==(e=this.args.enableMouseEvents)&&void 0!==e&&e}get enableTouchEvents(){var e;return null===(e=this.args.enableTouchEvents)||void 0===e||e}get touchSlop(){return this.args.touchSlop||0}get delayTouchStart(){var e,t;var s,o;return null!==(o=null!==(s=null===(e=this.args)||void 0===e?void 0:e.delayTouchStart)&&void 0!==s?s:null===(t=this.args)||void 0===t?void 0:t.delay)&&void 0!==o?o:0}get delayMouseStart(){var e,t;var s,o;return null!==(o=null!==(s=null===(e=this.args)||void 0===e?void 0:e.delayMouseStart)&&void 0!==s?s:null===(t=this.args)||void 0===t?void 0:t.delay)&&void 0!==o?o:0}get window(){return this.context&&this.context.window?this.context.window:"undefined"!==typeof window?window:void 0}get document(){var e;return(null===(e=this.context)||void 0===e?void 0:e.document)?this.context.document:this.window?this.window.document:void 0}get rootElement(){var e;return(null===(e=this.args)||void 0===e?void 0:e.rootElement)||this.document}constructor(e,t){this.args=e;this.context=t}}function distance(e,t,s,o){return Math.sqrt(Math.pow(Math.abs(s-e),2)+Math.pow(Math.abs(o-t),2))}function inAngleRanges(e,t,s,o,n){if(!n)return false;const i=180*Math.atan2(o-t,s-e)/Math.PI+180;for(let e=0;e<n.length;++e){const t=n[e];if(t&&(null==t.start||i>=t.start)&&(null==t.end||i<=t.end))return true}return false}const s={Left:1,Right:2,Center:4};const o={Left:0,Center:1,Right:2};
/**
 * Only touch events and mouse events where the left button is pressed should initiate a drag.
 * @param {MouseEvent | TouchEvent} e The event
 */function eventShouldStartDrag(e){return void 0===e.button||e.button===o.Left}
/**
 * Only touch events and mouse events where the left mouse button is no longer held should end a drag.
 * It's possible the user mouse downs with the left mouse button, then mouse down and ups with the right mouse button.
 * We don't want releasing the right mouse button to end the drag.
 * @param {MouseEvent | TouchEvent} e The event
 */function eventShouldEndDrag(e){return void 0===e.buttons||0===(e.buttons&s.Left)}function isTouchEvent(e){return!!e.targetTouches}const n=1;function getNodeClientOffset(e){const t=e.nodeType===n?e:e.parentElement;if(!t)return;const{top:s,left:o}=t.getBoundingClientRect();return{x:o,y:s}}function getEventClientTouchOffset(e,t){return 1===e.targetTouches.length?getEventClientOffset(e.targetTouches[0]):t&&1===e.touches.length&&e.touches[0].target===t.target?getEventClientOffset(e.touches[0]):void 0}function getEventClientOffset(e,t){return isTouchEvent(e)?getEventClientTouchOffset(e,t):{x:e.clientX,y:e.clientY}}const i=(()=>{let e=false;try{addEventListener("test",(()=>{}),Object.defineProperty({},"passive",{get(){e=true;return true}}))}catch(e){}return e})();const r={[t.mouse]:{start:"mousedown",move:"mousemove",end:"mouseup",contextmenu:"contextmenu"},[t.touch]:{start:"touchstart",move:"touchmove",end:"touchend"},[t.keyboard]:{keydown:"keydown"}};class TouchBackendImpl{profile(){var e;return{sourceNodes:this.sourceNodes.size,sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,targetNodes:this.targetNodes.size,dragOverTargetIds:(null===(e=this.dragOverTargetIds)||void 0===e?void 0:e.length)||0}}get document(){return this.options.document}setup(){const t=this.options.rootElement;if(t){e(!TouchBackendImpl.isSetUp,"Cannot have two Touch backends at the same time.");TouchBackendImpl.isSetUp=true;this.addEventListener(t,"start",this.getTopMoveStartHandler());this.addEventListener(t,"start",this.handleTopMoveStartCapture,true);this.addEventListener(t,"move",this.handleTopMove);this.addEventListener(t,"move",this.handleTopMoveCapture,true);this.addEventListener(t,"end",this.handleTopMoveEndCapture,true);this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.addEventListener(t,"contextmenu",this.handleTopMoveEndCapture);this.options.enableKeyboardEvents&&this.addEventListener(t,"keydown",this.handleCancelOnEscape,true)}}teardown(){const e=this.options.rootElement;if(e){TouchBackendImpl.isSetUp=false;this._mouseClientOffset={};this.removeEventListener(e,"start",this.handleTopMoveStartCapture,true);this.removeEventListener(e,"start",this.handleTopMoveStart);this.removeEventListener(e,"move",this.handleTopMoveCapture,true);this.removeEventListener(e,"move",this.handleTopMove);this.removeEventListener(e,"end",this.handleTopMoveEndCapture,true);this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.removeEventListener(e,"contextmenu",this.handleTopMoveEndCapture);this.options.enableKeyboardEvents&&this.removeEventListener(e,"keydown",this.handleCancelOnEscape,true);this.uninstallSourceNodeRemovalObserver()}}addEventListener(e,t,s,o=false){const n=i?{capture:o,passive:false}:o;this.listenerTypes.forEach((function(o){const i=r[o][t];i&&e.addEventListener(i,s,n)}))}removeEventListener(e,t,s,o=false){const n=i?{capture:o,passive:false}:o;this.listenerTypes.forEach((function(o){const i=r[o][t];i&&e.removeEventListener(i,s,n)}))}connectDragSource(e,t){const s=this.handleMoveStart.bind(this,e);this.sourceNodes.set(e,t);this.addEventListener(t,"start",s);return()=>{this.sourceNodes.delete(e);this.removeEventListener(t,"start",s)}}connectDragPreview(e,t,s){this.sourcePreviewNodeOptions.set(e,s);this.sourcePreviewNodes.set(e,t);return()=>{this.sourcePreviewNodes.delete(e);this.sourcePreviewNodeOptions.delete(e)}}connectDropTarget(e,t){const s=this.options.rootElement;if(!this.document||!s)return()=>{};const handleMove=o=>{if(!this.document||!s||!this.monitor.isDragging())return;let n;switch(o.type){case r.mouse.move:n={x:o.clientX,y:o.clientY};break;case r.touch.move:var i,a;n={x:(null===(i=o.touches[0])||void 0===i?void 0:i.clientX)||0,y:(null===(a=o.touches[0])||void 0===a?void 0:a.clientY)||0};break}const h=null!=n?this.document.elementFromPoint(n.x,n.y):void 0;const d=h&&t.contains(h);return h===t||d?this.handleMove(o,e):void 0};this.addEventListener(this.document.body,"move",handleMove);this.targetNodes.set(e,t);return()=>{if(this.document){this.targetNodes.delete(e);this.removeEventListener(this.document.body,"move",handleMove)}}}getTopMoveStartHandler(){return this.options.delayTouchStart||this.options.delayMouseStart?this.handleTopMoveStartDelay:this.handleTopMoveStart}installSourceNodeRemovalObserver(e){this.uninstallSourceNodeRemovalObserver();this.draggedSourceNode=e;this.draggedSourceNodeRemovalObserver=new MutationObserver((()=>{if(e&&!e.parentElement){this.resurrectSourceNode();this.uninstallSourceNodeRemovalObserver()}}));e&&e.parentElement&&this.draggedSourceNodeRemovalObserver.observe(e.parentElement,{childList:true})}resurrectSourceNode(){if(this.document&&this.draggedSourceNode){this.draggedSourceNode.style.display="none";this.draggedSourceNode.removeAttribute("data-reactid");this.document.body.appendChild(this.draggedSourceNode)}}uninstallSourceNodeRemovalObserver(){this.draggedSourceNodeRemovalObserver&&this.draggedSourceNodeRemovalObserver.disconnect();this.draggedSourceNodeRemovalObserver=void 0;this.draggedSourceNode=void 0}constructor(e,s,o){this.getSourceClientOffset=e=>{const t=this.sourceNodes.get(e);return t&&getNodeClientOffset(t)};this.handleTopMoveStartCapture=e=>{eventShouldStartDrag(e)&&(this.moveStartSourceIds=[])};this.handleMoveStart=e=>{Array.isArray(this.moveStartSourceIds)&&this.moveStartSourceIds.unshift(e)};this.handleTopMoveStart=e=>{if(!eventShouldStartDrag(e))return;const t=getEventClientOffset(e);if(t){isTouchEvent(e)&&(this.lastTargetTouchFallback=e.targetTouches[0]);this._mouseClientOffset=t}this.waitingForDelay=false};this.handleTopMoveStartDelay=e=>{if(!eventShouldStartDrag(e))return;const t=e.type===r.touch.start?this.options.delayTouchStart:this.options.delayMouseStart;this.timeout=setTimeout(this.handleTopMoveStart.bind(this,e),t);this.waitingForDelay=true};this.handleTopMoveCapture=()=>{this.dragOverTargetIds=[]};this.handleMove=(e,t)=>{this.dragOverTargetIds&&this.dragOverTargetIds.unshift(t)};this.handleTopMove=e=>{this.timeout&&clearTimeout(this.timeout);if(!this.document||this.waitingForDelay)return;const{moveStartSourceIds:t,dragOverTargetIds:s}=this;const o=this.options.enableHoverOutsideTarget;const n=getEventClientOffset(e,this.lastTargetTouchFallback);if(!n)return;if(this._isScrolling||!this.monitor.isDragging()&&inAngleRanges(this._mouseClientOffset.x||0,this._mouseClientOffset.y||0,n.x,n.y,this.options.scrollAngleRanges)){this._isScrolling=true;return}if(!this.monitor.isDragging()&&this._mouseClientOffset.hasOwnProperty("x")&&t&&distance(this._mouseClientOffset.x||0,this._mouseClientOffset.y||0,n.x,n.y)>(this.options.touchSlop?this.options.touchSlop:0)){this.moveStartSourceIds=void 0;this.actions.beginDrag(t,{clientOffset:this._mouseClientOffset,getSourceClientOffset:this.getSourceClientOffset,publishSource:false})}if(!this.monitor.isDragging())return;const i=this.sourceNodes.get(this.monitor.getSourceId());this.installSourceNodeRemovalObserver(i);this.actions.publishDragSource();e.cancelable&&e.preventDefault();const r=(s||[]).map((e=>this.targetNodes.get(e))).filter((e=>!!e));const a=this.options.getDropTargetElementsAtPoint?this.options.getDropTargetElementsAtPoint(n.x,n.y,r):this.document.elementsFromPoint(n.x,n.y);const h=[];for(const e in a){if(!a.hasOwnProperty(e))continue;let t=a[e];null!=t&&h.push(t);while(t){t=t.parentElement;t&&-1===h.indexOf(t)&&h.push(t)}}const d=h.filter((e=>r.indexOf(e)>-1)).map((e=>this._getDropTargetId(e))).filter((e=>!!e)).filter(((e,t,s)=>s.indexOf(e)===t));if(o)for(const e in this.targetNodes){const t=this.targetNodes.get(e);if(i&&t&&t.contains(i)&&-1===d.indexOf(e)){d.unshift(e);break}}d.reverse();this.actions.hover(d,{clientOffset:n})};this._getDropTargetId=e=>{const t=this.targetNodes.keys();let s=t.next();while(false===s.done){const o=s.value;if(e===this.targetNodes.get(o))return o;s=t.next()}};this.handleTopMoveEndCapture=e=>{this._isScrolling=false;this.lastTargetTouchFallback=void 0;if(eventShouldEndDrag(e))if(this.monitor.isDragging()&&!this.monitor.didDrop()){e.cancelable&&e.preventDefault();this._mouseClientOffset={};this.uninstallSourceNodeRemovalObserver();this.actions.drop();this.actions.endDrag()}else this.moveStartSourceIds=void 0};this.handleCancelOnEscape=e=>{if("Escape"===e.key&&this.monitor.isDragging()){this._mouseClientOffset={};this.uninstallSourceNodeRemovalObserver();this.actions.endDrag()}};this.options=new OptionsReader(o,s);this.actions=e.getActions();this.monitor=e.getMonitor();this.sourceNodes=new Map;this.sourcePreviewNodes=new Map;this.sourcePreviewNodeOptions=new Map;this.targetNodes=new Map;this.listenerTypes=[];this._mouseClientOffset={};this._isScrolling=false;this.options.enableMouseEvents&&this.listenerTypes.push(t.mouse);this.options.enableTouchEvents&&this.listenerTypes.push(t.touch);this.options.enableKeyboardEvents&&this.listenerTypes.push(t.keyboard)}}const a=function createBackend(e,t={},s={}){return new TouchBackendImpl(e,t,s)};export{t as ListenerType,a as TouchBackend,TouchBackendImpl};

