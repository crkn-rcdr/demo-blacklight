var e={};var t=Object.defineProperty;var r=Object.getOwnPropertyDescriptor;var n=Object.getOwnPropertyNames;var o=Object.prototype.hasOwnProperty;var __export=(e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:true})};var __copyProps=(e,a,c,s)=>{if(a&&typeof a==="object"||typeof a==="function")for(let l of n(a))o.call(e,l)||l===c||t(e,l,{get:()=>a[l],enumerable:!(s=r(a,l))||s.enumerable});return e};var __toCommonJS=e=>__copyProps(t({},"__esModule",{value:true}),e);var a={};__export(a,{createSelector:()=>z,createSelectorCreator:()=>createSelectorCreator,createStructuredSelector:()=>k,lruMemoize:()=>lruMemoize,referenceEqualityCheck:()=>referenceEqualityCheck,setGlobalDevModeChecks:()=>setGlobalDevModeChecks,unstable_autotrackMemoize:()=>autotrackMemoize,weakMapMemoize:()=>weakMapMemoize});e=__toCommonJS(a);var c={inputStabilityCheck:"once",identityFunctionCheck:"once"};var setGlobalDevModeChecks=e=>{Object.assign(c,e)};var s="NOT_FOUND";function assertIsFunction(e,t="expected a function, instead received "+typeof e){if(typeof e!=="function")throw new TypeError(t)}function assertIsObject(e,t="expected an object, instead received "+typeof e){if(typeof e!=="object")throw new TypeError(t)}function assertIsArrayOfFunctions(e,t="expected all items to be functions, instead received the following types: "){if(!e.every((e=>typeof e==="function"))){const r=e.map((e=>typeof e==="function"?`function ${e.name||"unnamed"}()`:typeof e)).join(", ");throw new TypeError(`${t}[${r}]`)}}var ensureIsArray=e=>Array.isArray(e)?e:[e];function getDependencies(e){const t=Array.isArray(e[0])?e[0]:e;assertIsArrayOfFunctions(t,"createSelector expects all input-selectors to be functions, but received the following types: ");return t}function collectInputSelectorResults(e,t){const r=[];const{length:n}=e;for(let o=0;o<n;o++)r.push(e[o].apply(null,t));return r}var l=0;var i=null;var u=class{revision=l;_value;_lastValue;_isEqual=tripleEq;constructor(e,t=tripleEq){this._value=this._lastValue=e;this._isEqual=t}get value(){i?.add(this);return this._value}set value(e){if(this.value!==e){this._value=e;this.revision=++l}}};function tripleEq(e,t){return e===t}var f=class{_cachedValue;_cachedRevision=-1;_deps=[];hits=0;fn;constructor(e){this.fn=e}clear(){this._cachedValue=void 0;this._cachedRevision=-1;this._deps=[];this.hits=0}get value(){if(this.revision>this._cachedRevision){const{fn:e}=this;const t=new Set;const r=i;i=t;this._cachedValue=e();i=r;this.hits++;this._deps=Array.from(t);this._cachedRevision=this.revision}i?.add(this);return this._cachedValue}get revision(){return Math.max(...this._deps.map((e=>e.revision)),0)}};function getValue(e){e instanceof u||console.warn("Not a valid cell! ",e);return e.value}function setValue(e,t){if(!(e instanceof u))throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");e.value=e._lastValue=t}function createCell(e,t=tripleEq){return new u(e,t)}function createCache(e){assertIsFunction(e,"the first parameter to `createCache` must be a function");return new f(e)}var neverEq=(e,t)=>false;function createTag(){return createCell(null,neverEq)}function dirtyTag(e,t){setValue(e,t)}var consumeCollection=e=>{let t=e.collectionTag;t===null&&(t=e.collectionTag=createTag());getValue(t)};var dirtyCollection=e=>{const t=e.collectionTag;t!==null&&dirtyTag(t,null)};Symbol();var p=0;var d=Object.getPrototypeOf({});var h=class{constructor(e){this.value=e;this.value=e;this.tag.value=e}proxy=new Proxy(e,v);tag=createTag();tags={};children={};collectionTag=null;id=p++};var v={get(e,t){function calculateResult(){const{value:r}=e;const n=Reflect.get(r,t);if(typeof t==="symbol")return n;if(t in d)return n;if(typeof n==="object"&&n!==null){let r=e.children[t];r===void 0&&(r=e.children[t]=createNode(n));r.tag&&getValue(r.tag);return r.proxy}{let r=e.tags[t];if(r===void 0){r=e.tags[t]=createTag();r.value=n}getValue(r);return n}}const r=calculateResult();return r},ownKeys(e){consumeCollection(e);return Reflect.ownKeys(e.value)},getOwnPropertyDescriptor(e,t){return Reflect.getOwnPropertyDescriptor(e.value,t)},has(e,t){return Reflect.has(e.value,t)}};var y=class{constructor(e){this.value=e;this.value=e;this.tag.value=e}proxy=new Proxy([e],m);tag=createTag();tags={};children={};collectionTag=null;id=p++};var m={get([e],t){t==="length"&&consumeCollection(e);return v.get(e,t)},ownKeys([e]){return v.ownKeys(e)},getOwnPropertyDescriptor([e],t){return v.getOwnPropertyDescriptor(e,t)},has([e],t){return v.has(e,t)}};function createNode(e){return Array.isArray(e)?new y(e):new h(e)}function updateNode(e,t){const{value:r,tags:n,children:o}=e;e.value=t;if(Array.isArray(r)&&Array.isArray(t)&&r.length!==t.length)dirtyCollection(e);else if(r!==t){let n=0;let o=0;let a=false;for(const e in r)n++;for(const e in t){o++;if(!(e in r)){a=true;break}}const c=a||n!==o;c&&dirtyCollection(e)}for(const o in n){const a=r[o];const c=t[o];if(a!==c){dirtyCollection(e);dirtyTag(n[o],c)}typeof c==="object"&&c!==null&&delete n[o]}for(const e in o){const r=o[e];const n=t[e];const a=r.value;if(a!==n)if(typeof n==="object"&&n!==null)updateNode(r,n);else{deleteNode(r);delete o[e]}}}function deleteNode(e){e.tag&&dirtyTag(e.tag,null);dirtyCollection(e);for(const t in e.tags)dirtyTag(e.tags[t],null);for(const t in e.children)deleteNode(e.children[t])}function createSingletonCache(e){let t;return{get(r){return t&&e(t.key,r)?t.value:s},put(e,r){t={key:e,value:r}},getEntries(){return t?[t]:[]},clear(){t=void 0}}}function createLruCache(e,t){let r=[];function get(e){const n=r.findIndex((r=>t(e,r.key)));if(n>-1){const e=r[n];if(n>0){r.splice(n,1);r.unshift(e)}return e.value}return s}function put(t,n){if(get(t)===s){r.unshift({key:t,value:n});r.length>e&&r.pop()}}function getEntries(){return r}function clear(){r=[]}return{get:get,put:put,getEntries:getEntries,clear:clear}}var referenceEqualityCheck=(e,t)=>e===t;function createCacheKeyComparator(e){return function areArgumentsShallowlyEqual(t,r){if(t===null||r===null||t.length!==r.length)return false;const{length:n}=t;for(let o=0;o<n;o++)if(!e(t[o],r[o]))return false;return true}}function lruMemoize(e,t){const r=typeof t==="object"?t:{equalityCheck:t};const{equalityCheck:n=referenceEqualityCheck,maxSize:o=1,resultEqualityCheck:a}=r;const c=createCacheKeyComparator(n);let l=0;const i=o===1?createSingletonCache(c):createLruCache(o,c);function memoized(){let t=i.get(arguments);if(t===s){t=e.apply(null,arguments);l++;if(a){const e=i.getEntries();const r=e.find((e=>a(e.value,t)));if(r){t=r.value;l!==0&&l--}}i.put(arguments,t)}return t}memoized.clearCache=()=>{i.clear();memoized.resetResultsCount()};memoized.resultsCount=()=>l;memoized.resetResultsCount=()=>{l=0};return memoized}function autotrackMemoize(e){const t=createNode([]);let r=null;const n=createCacheKeyComparator(referenceEqualityCheck);const o=createCache((()=>{const r=e.apply(null,t.proxy);return r}));function memoized(){if(!n(r,arguments)){updateNode(t,arguments);r=arguments}return o.value}memoized.clearCache=()=>o.clear();return memoized}var g=class{constructor(e){this.value=e}deref(){return this.value}};var C=typeof WeakRef!=="undefined"?WeakRef:g;var w=0;var b=1;function createCacheNode(){return{s:w,v:void 0,o:null,p:null}}function weakMapMemoize(e,t={}){let r=createCacheNode();const{resultEqualityCheck:n}=t;let o;let a=0;function memoized(){let t=r;const{length:c}=arguments;for(let e=0,r=c;e<r;e++){const r=arguments[e];if(typeof r==="function"||typeof r==="object"&&r!==null){let e=t.o;e===null&&(t.o=e=new WeakMap);const n=e.get(r);if(n===void 0){t=createCacheNode();e.set(r,t)}else t=n}else{let e=t.p;e===null&&(t.p=e=new Map);const n=e.get(r);if(n===void 0){t=createCacheNode();e.set(r,t)}else t=n}}const s=t;let l;if(t.s===b)l=t.v;else{l=e.apply(null,arguments);a++}s.s=b;if(n){const e=o?.deref?.()??o;if(e!=null&&n(e,l)){l=e;a!==0&&a--}const t=typeof l==="object"&&l!==null||typeof l==="function";o=t?new C(l):l}s.v=l;return l}memoized.clearCache=()=>{r=createCacheNode();memoized.resetResultsCount()};memoized.resultsCount=()=>a;memoized.resetResultsCount=()=>{a=0};return memoized}function createSelectorCreator(e,...t){const r=typeof e==="function"?{memoize:e,memoizeOptions:t}:e;const createSelector2=(...e)=>{let t=0;let n=0;let o;let a={};let c=e.pop();if(typeof c==="object"){a=c;c=e.pop()}assertIsFunction(c,`createSelector expects an output function after the inputs, but received: [${typeof c}]`);const s={...r,...a};const{memoize:l,memoizeOptions:i=[],argsMemoize:u=weakMapMemoize,argsMemoizeOptions:f=[],devModeChecks:p={}}=s;const d=ensureIsArray(i);const h=ensureIsArray(f);const v=getDependencies(e);const y=l((function recomputationWrapper(){t++;return c.apply(null,arguments)}),...d);const m=u((function dependenciesChecker(){n++;const e=collectInputSelectorResults(v,arguments);o=y.apply(null,e);return o}),...h);return Object.assign(m,{resultFunc:c,memoizedResultFunc:y,dependencies:v,dependencyRecomputations:()=>n,resetDependencyRecomputations:()=>{n=0},lastResult:()=>o,recomputations:()=>t,resetRecomputations:()=>{t=0},memoize:l,argsMemoize:u})};Object.assign(createSelector2,{withTypes:()=>createSelector2});return createSelector2}var z=createSelectorCreator(weakMapMemoize);var k=Object.assign(((e,t=z)=>{assertIsObject(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a "+typeof e);const r=Object.keys(e);const n=r.map((t=>e[t]));const o=t(n,((...e)=>e.reduce(((e,t,n)=>{e[r[n]]=t;return e}),{})));return o}),{withTypes:()=>k});0;var M=e;const S=e.createSelector,O=e.createSelectorCreator,_=e.createStructuredSelector,j=e.lruMemoize,R=e.referenceEqualityCheck,T=e.setGlobalDevModeChecks,E=e.unstable_autotrackMemoize,N=e.weakMapMemoize;export{S as createSelector,O as createSelectorCreator,_ as createStructuredSelector,M as default,j as lruMemoize,R as referenceEqualityCheck,T as setGlobalDevModeChecks,E as unstable_autotrackMemoize,N as weakMapMemoize};

